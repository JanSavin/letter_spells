//Отдельный файл чтобы сначало научиться прользоваться разными штуками и только потом включать эти штуки в основной файл

#include <iostream>
#include <windows.h>
#include <fstream>
using namespace std;

//отличие sctruct от class

enum class ValueQuality
{
	мусор, обычное, редкое, мифическое, легендарное //эквивалент перечисления
};

Elenum class CharacterType {
UNKNOWN = 0,
WARRIOR,
WIZARD,
PALADIN
}

unique_ptr<Npc> character;
        switch (TestChoise(3, "Такого еще не было в наших краях\nНе мог бы ты повторить"))
        {
            case 1:
                character = CreateCharacter(CharacterType::WARRIOR);
                break;
            case 2: 
                character = CreateCharacter(CharacterType::WIZARD);
                break;
            case 3: 
                character = CreateCharacter(CharacterType::PALADIN);
                break;
        }
        player->Create(move(character));

unique_ptr<Npc> CreateCharacter(CharacterType type)
{
    switch (type)
    {
    case CharacterType::UNKNOWN:
        return make_unique<Npc>();
        break;
    case CharacterType::WARRIOR:
        return make_unique<Warrior>();
        break;
    case CharacterType::WIZARD:
        return make_unique<Wizard>();
        break;
    case CharacterType::PALADIN:
        return make_unique<Paladin>();
        break;
    default:
        throw
            invalid_argument("Неизвесный тип персонажа");
        break;
    }
}


struct Treasure //по умолчанию все внутри public
{
    Treasure() = default;
    string name{ "добыча" };
    ValueQuality quality = ValueQuality::мифическое;
    unsigned int price{ 0 };
    Treasure(ValueQuality quality)
    {
        switch (quality)
        {
        case ValueQuality::мусор:
            cout << "качество плохое\n";
            break;
        case ValueQuality::обычное:
            cout << "качество средненькое\n";
            break;
        case ValueQuality::редкое:
            cout << "качество хорошее\n";
            break;
        case ValueQuality::мифическое:
            cout << "качество крутое\n";
            break;
        case ValueQuality::легендарное:
            cout << "качество идеальное\n";
            break;
        default:
            break;
        }
    }
};

// class Treasure //по умолчанию private
// {
// 	string name{"добыча"};
// 	string quality[3]{"мусор","обфчное","редкое"};
// 	unsigned int price{ 0 };
// };
struct Cloth : Treasure //наследование по умолчанию public
Cloth(ValueQuality quality) : Treasure(quality) {};
string valueSite[5]{ "обувь", "перчатки", "шлем", "нагрудник", "пояс" };
string site{NULL};
unsigned short armor{ 1 };

//наследлванеи
//модификаторы доступа
//private - внутри класса
//protected - наследник
//public - общедоступный

//базовый класс (обстрактный)
class Npc
{
protected: //модификатор доступа (приватный - защищенный, доступ к полям, только внутри класса)
	string name{ "персонаж" };
	unsigned int health{ 10 };
	float damage{ 5 };
	unsigned short lvl{ 1 };
public: //публичный модификатор доступ (использовать метод можно в любом месте)
	virtual void GetInfo() //метод класса
	{
		cout << "Имя - " << name << endl;
		cout << "Здоровье - " << health << endl;
		cout << "Урон - " << damage << endl;
	}
	string GetName() const { return name; };
	unsigned int GetHealth() const { return health; };
	float GetDamage() const { return damage; };
	unsigned short GetLvl() const { return lvl; };

	//Дружественные функции
	friend void TakeDamage(Npc& npc, float damage) {};

	void Save(){
		ofstream saveSystem("save.bin",ios:: binary);
	if (!saveSystem.is_open()){
	cout << "Ошибка сохранения\n";
	}else{
		size_t length = name.length();
	saveSystem.write(reinterpret_cast<const char*>(&(length)), sizeof(length));
	saveSystem.write(reinterpret_cast<const char*>(&(name)), sizeof(name));
	saveSystem.write(reinterpret_cast<const char*>(&(health)), sizeof(health));
	saveSystem.write(reinterpret_cast<const char*>(&(damage)), sizeof(damage));
	saveSystem.write(reinterpret_cast<const char*>(&(lvl)), sizeof(lvl));}
	virtual ~Npc() = default; //default - по умолчанию, чтобы не писать {} тело пустое
};
	void Load(){
	ifstream loadSystem("save.txt", ios::binary);
	Npc npc;
	if (!loadSystem.is_open()){

	size_t nameLenght;
      loadSystem.read(reinterpret_cast<char*>(&nameLenght), sizeof(nameLenght));
      char* buffer = new char[nameLenght + 1];
      loadSystem.read(buffer,nameLenght);
      buffer[nameLenght] = '\0';
      npc.name = string(buffer);
      delete[] buffer;

	loadSystem.read(reinterpret_cast<char*>(&(npc.name)), sizeof(npc.name));
	loadSystem.read(reinterpret_cast<char*>(&(npc.health)), sizeof(npc.health));
	loadSystem.read(reinterpret_cast<char*>(&(npc.damage)), sizeof(npc.damage));
	loadSystem.read(reinterpret_cast<char*>(&(npc.lvl)), sizeof(npc.lvl));
	return npc;
	};}
};

class Elf : public Npc
{
private:
	string npc_class = { "Эльф" };
	unsigned short strenght{ 15 };
	string weapons[4] = { "ничего","хлипкий лук","продвинутый лук","лук снайпера" };
public:
	Elf()
	{
		name = { "Эльф" };
		health = { 8 };
		damage = { 3 };
	}
	Elf(string name, unsigned int health, float damage)
	{
		this->name = name;
		this->health = health;
		this->damage = damage;
	}

	void GetWeapons()
	{
		cout << name << " взял " << weapons[lvl - 1];
	}
	void GetInfo() override //метод класса
	{
		cout << "Персонаж: " << npc_class << endl;
		Npc::GetInfo();
		cout << "Сила - " << strenght << endl;
		for (int i = 0;i < lvl;i++)
		{
			cout << "Оружие (доступное) - " << weapons[i] << endl;
		}
	}
	void Create() override
	{
		cout << "Персонаж эльф создан." << endl;
		cout << "Назовите персонажа: ";
		cin >> name;
		GetInfo();
		GetWeapons();
	}

	~Elf()
	{
		cout << name << " покинул поле." << endl;
	}
};

//наследование доступных свойств и методов класса
class Hiller : public Npc
{
private:
	string npc_class = { "Лекарь" };
	unsigned short strenght{ 10 };
	string weapons[4] = { "подорожник","малая аптечка","исцеляющий снадобья","хирургические приблуды" };
public:
	Hiller()
	{
		name = { "Лекарь" };
		health = { 30 };
		damage = { 1 };
	}
	Hiller(string name, unsigned int health, float damage)
	{
		this->name = name;
		this->health = health;
		this->damage = damage;
	}

	void GetWeapons()
	{
		cout << name << " взял " << weapons[lvl - 1];
	}
	void GetInfo() //метод класса
	{
		cout << "Персонаж: " << npc_class << endl;
		Npc::GetInfo();
		cout << "Исцеление - " << strenght << endl;
		for (int i = 0;i < lvl;i++)
		{
			cout << "Предметы (доступное) - " << weapons[i] << endl;
		}
	}
	void Create() override
  {
    cout << "Вы создали Лекаря" << endl;
    cout << "Введите имя персонажа\t";
    cin >> name;
    GetInfo();
    GetWeapons();
  }

  //перегрузка
  bool operator == (const Hiller& hiller) const
  {
    return ((hiller.damage == this->damage) && (hiller.health == this->health)
      && (hiller.strenght == this->strenght));
  }

	~Hiller()
	{
		cout << name << " покинул поле." << endl;
	}
};

class Wizard : public virtual Npc
{
	class Spell
	{
	protected:
		string name{ "заклинание" };
		unsigned short damage{ 0 };
		unsigned short price{ 0 };
		bool isCurse{ false };
		int time{ 0 };
	public:
		Spell(string name = "заклинание",  unsigned short price = 0, bool isCurse = false, int time = 0)
		{
			this ->name = name;
			this ->price = price;
			this ->isCurse = isCurse;
			this ->time = time;
		}

		string operator[](unsigned index) const
		{
			switch (index)
			{
				case 0: return "Название - " + name; break;
				case 1: return "Урон - " + to_string(damage); break;
				case 2: return "Стоимость применения - "+ to_string(price) + " маны"; break;
				case 3:
				{
					if (isCurse)
					{
						return "периодичный урон";
					} else {
						return "произносимое заклинание";
					}
					break;
				}
				case 4:
					return isCurse ? "Длительность негативного эффекта - "+to_string(timeCast):
					"Длительность применения - " + to_string(timeCast);
					break;
				default: return "такого свойства заклинания не существует";
					break;
			}
		}


		unsigned short CastSpell()
		{
			cout << "Вы применили " << name << " на противнике" << endl;
			return damage;
		}
	};
protected:
	unsigned short intellect = 27;
	Spell spells[5] = {
		Spell("огненный шар",20,50,false,3),
		Spell("волшебные стрелы",10,30,false,1),
		Spell("ледяной шок",10,20,false),
		Spell("возгорание",10,25, true,5),
		Spell("проклятие",5,10,false, 10),
	};
public:
	Wizard();
	Wizard(string name, unsigned int health, float damage);
	void GetInfo() override;
	void CastSpell();
	void Create() override;
	Wizard operator + (const Wizard& wizard) const;
	bool Save() override;
	~Wizard();
}

void Wizard::GetInfo()
{
	Npc: :GetInfo();
	cout << "Интеллект - " << intellect << endl;
	cout << "Доступные заклинания в книге заклинаний - "
	for (int i = 0; i < 5; i++)
	{
		cout << i + 1 << " заклинание:\n";
		for(int j =0; j < 5; j++)
		{
			cout << spells[i][j] << endl;
		}
		cout << endl;
	}
}

class BadGuy
{
protected: 
	string name;
	unsigned int health{ 10 };
	float damage{ 5 };
	unsigned short lvl{ 1 };
	bool isAlive;
public:
	BadGuy(string n, unsigned int h, float d, unsigned short l, bool is):
		name(n),health(h),damage(d),lvl(l),isAlive(is)
	{
		cout << n << "coming..\n";
	}
	BadGuy():BadGuy("Dark Lord", 100, 150, 5, true) {}
};

class Player
{
  public:
    void Create(Npc* player)
    {
      player->Create();
    }
	void Save(Npc* player)
    {
      player->Save();
    }
	Npc Load(Npc* player)
    {
      size_t nameLength;
	loadSystem.read(reinterpret_cast<char*>(&nameLength), sizeof(nameLength));
	char* buffer = new char[nameLength + 1];
	loadSystem.read(buffer, nameLength);
	buffer[nameLength] = '\0';
	npc.name = string(buffer);
	delete[] buffer;
	loadSystem.read(reinterpret_cast<char*>(&npc.health), sizeof(npc.health));
	loadSystem.read(reinterpret_cast<char*>(&npc.damage), sizeof(npc.damage));
	loadSystem.read(reinterpret_cast<char*>(&npc.lvl), sizeof(npc.lvl));
	return loadSystem.good();
    }
};

struct Weapon
{
	string name{"name"};
	string discription{"cold and blody"};
	float damage{0};
	float speed{0};
};
struct Weapon
{
	string name{"name"};
	string discription{"cold and blody"};
	float damage{0};
	float speed{0};
};

class Player{
private:
unique_ptr<Npc> currentCharacter;
public:
void Create(Npc* player)
player->Create();
void Save(Npc* player)
player->Save();
Npc Load(Npc* player)
}

void TakeDamage(Npc& npc, float damage) {
	float* tempHealth = new float;
	*tempHealth = (float)npc.health - damage; //добавить свойство (броня) и ввести его в формулу
	if (*tempHealth < 0)
	{
		cout << "Персонаж мёртв" << endl;
	}else{
		npc.health = *tempHealth;
	}
	delete tempHealth;
	tempHealth = nullptr;
}

int main()
{
	setlocale(LC_ALL, "Rus");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
 


	return 0;
}
